<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>第一章 - ECE搭车客指南</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../css/brands.min.css" rel="stylesheet">
        <link href="../../css/solid.min.css" rel="stylesheet">
        <link href="../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <link href="../../css/extra.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">ECE搭车客指南</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../.." class="nav-link">首页</a>
                            </li>
                            <li class="nav-item">
                                <a href="../../%E5%88%9D%E5%BF%83%E5%92%8C%E4%BD%BF%E5%91%BD/" class="nav-link">初心与使命</a>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle active" aria-current="page" role="button" data-bs-toggle="dropdown"  aria-expanded="false">ECE120</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../%E5%BA%8F/" class="dropdown-item">序</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active" aria-current="page">第一章</a>
</li>
                                    
<li>
    <a href="../Chapter2/" class="dropdown-item">第二章</a>
</li>
                                    
<li>
    <a href="../Chapter3/" class="dropdown-item">第三章</a>
</li>
                                    
<li>
    <a href="../Chapter4/" class="dropdown-item">第四章</a>
</li>
                                    
<li>
    <a href="../Chapter5/" class="dropdown-item">第五章</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">ECE220</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../ECE220/%E5%BA%8F/" class="dropdown-item">序</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../%E5%BA%8F/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../Chapter2/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#_1" class="nav-link">计算机中的数值表示</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#unsign-representation" class="nav-link">Unsign Representation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#signed-magnitude-representation" class="nav-link">Signed-Magnitude Representation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#2s-complement" class="nav-link">2's Complement</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#fixed-point-representation" class="nav-link">Fixed Point representation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#floating-point-representation" class="nav-link">Floating Point representation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#overflow-problem" class="nav-link">Overflow Problem</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#hexadecimal" class="nav-link">Hexadecimal</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_2" class="nav-link">写在最后的话</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="_1">计算机中的数值表示<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h1>
<p>representation可以理解为一种函数映射关系，需要一一对应。由于计算机中的所有信息都是由电位的高低两种状态表示的，本节内容主要讲述如何将数字映射到bits</p>
<p><img alt="representation_all" src="../picture/c1/representation_all.png" /></p>
<h2 id="unsign-representation">Unsign Representation<a class="headerlink" href="#unsign-representation" title="Permanent link">&para;</a></h2>
<p>N-bits unsign representation：二进制+补零对齐(补足N位)</p>
<ul>
<li>如何从二进制转化到十进制 --按位计算</li>
<li>如何从十进制转化到二进制 --中国宝宝短除法</li>
</ul>
<p>应付考试的话会算就可以了，但是此处ppt解释了进制转化的原理，其实对于K进制，原理都是相通的（把一个数表达成关于K的多项式）</p>
<p>例如，对于 K 进制数 <span class="arithmatex">\((a_4a_3a_2a_1a_0)_k\)</span>:</p>
<div class="arithmatex">\[
(a_4a_3a_2a_1a_0)_k = a_4 \times k^4 + a_3 \times k^3 + a_2 \times k^2 + a_1 \times k^1 + a_0 \times k^0
\]</div>
<p>根据多项式表达，想要把 K 进制转化成十进制，很容易，只要把等式右边的一项求出来。</p>
<p>如果把十进制转化成 K 进制：</p>
<div class="arithmatex">\[
\frac{(a_4a_3a_2a_1a_0)_k}{k} = a_4 \times k^3 + a_3 \times k^2 + a_2 \times k^1 + a_1 \times k^0 + \frac{a_0}{k} \quad \text{余} \quad a_0
\]</div>
<p>这样余数就是我们所需要的，之后去前面整数部分重复同样的运算：</p>
<div class="arithmatex">\[
\frac{a_4 \times k^3 + a_3 \times k^2 + a_2 \times k^1 + a_1 \times k^0}{k} \quad \text{余} \quad a_1
\]</div>
<p>得出 <span class="arithmatex">\(a_1\)</span>，到这里就可以看出为什么短除法，最后的余数结果是需要倒着写回去的。</p>
<p>基于把各个进制的数表达为一个多项式，我们可以实现任意进制之间的转化。</p>
<p>e.g <span class="arithmatex">\((101010)_2\)</span> &lt;-&gt; <span class="arithmatex">\((42)_{10}\)</span></p>
<p>如：二进制到十进制:</p>
<div class="arithmatex">\[
1 \times 2^5 + 0 \times 2^4 + 1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 0 \times 2^0 = 32 + 0 + 8 + 0 + 2 + 0 = 42_{10}
\]</div>
<p>十进制到二进制:</p>
<p>用 42 除以 2：</p>
<ul>
<li>42 ÷ 2 = 21 余 0  </li>
<li>21 ÷ 2 = 10 余 1  </li>
<li>10 ÷ 2 = 5 余 0  </li>
<li>5 ÷ 2 = 2 余 1  </li>
<li>2 ÷ 2 = 1 余 0  </li>
<li>1 ÷ 2 = 0 余 1  </li>
</ul>
<p>考点：1.十进制与unsign representaion之间的互相转换 2.overflow问题，见<a href="#overflow-problem">Overflow problem</a></p>
<h2 id="signed-magnitude-representation">Signed-Magnitude Representation<a class="headerlink" href="#signed-magnitude-representation" title="Permanent link">&para;</a></h2>
<p>(not very important: because it is not a good representation)
考试一般不会考，用以引入2‘s complement
<br><br>
Signed-Magnitude Representation基于人类表示负数的思想（在正数前加一个负号），把第一位当作符号位置，0表示正数，1表示负数
<img alt="Signed-Magnitude" src="../picture/c1/signed-magnitude.png" />
<br><br>
问题：</p>
<ul>
<li>有两个0，正0和负0，导致representation的浪费和运算的复杂</li>
<li>不符合常规运算的准则：e.g 1011（-3）+ 0100（4） = 1111（-7）
<br><br>
<img alt="Signed-Magnitude" src="../picture/c1/signed-magnitude%20problem.png" /></li>
</ul>
<h2 id="2s-complement">2's Complement<a class="headerlink" href="#2s-complement" title="Permanent link">&para;</a></h2>
<p style="font-family: Arial, sans-serif; font-size: 1em; text-align: left;">
  ⚠️very important
</p>
<p>所有的representation的共同点就是，可以用的bit位是固定的--&gt;运算是不封闭的</p>
<p>不封闭：把representation的所有可能看做一个集合，取集合中的元素进行运算，运算产生的元素不在集合内(overflow)，则这个representation是不封闭的 e.g 4-bits-unsigned representation 1011（11）+0111（7） = 10010（18） 10010已经不在4-bits-unsigned representation的这个集合内了</p>
<p>为了设计一个在忽略overflow的情况下，满足现有计算法则并且能同时表示正数和负数的representation，我们首先要清楚普通的unsigned representation运算背后的数学本质：同余</p>
<p>根据刚才的例子：</p>
<ul>
<li>1011（11）+0111（7） = 10010（18）</li>
</ul>
<p>如果一定要让结果能被4-bits-unsigned representation表示，那么就只能保留后四位，0010（2），保留后四位的操作相当于什么呢？</p>
<ul>
<li><span class="arithmatex">\((10010)_2\)</span> <span class="arithmatex">\(\div\)</span> <span class="arithmatex">\((16)_{10}\)</span> = <span class="arithmatex">\((10010)_2\)</span> <span class="arithmatex">\(\div\)</span> <span class="arithmatex">\(2^4\)</span> = 0010 </li>
</ul>
<p>同余的定义：如果两个数A, B可以表示为 A = B + k * M 其中k是整数，那么可以写作 <span class="arithmatex">\(A \equiv B \pmod{M}\)</span>，A和B对模M同余（其实关于K也可以啦，反正M和k都是整数） e.g 0010(2) + 1 * 16 = 10010(18) 那么就可以说2和18对模16同余</p>
<p>当两个N-bits-unsigned representation相加时，如果结果超出了最大值<span class="arithmatex">\(2^N - 1\)</span>，只保留<strong>低</strong>N位的操作，等价于相加结果对<span class="arithmatex">\(2^N\)</span>取模</p>
<p>基于对unsigned-representation运算的理解，我们就可以开始设计合理的负数表示 -- 2's complement</p>
<p><img alt="modular arithmetic" src="../picture/c1/modular_arithmetic.png" /></p>
<p>在这张图中，顺时针方向是加，逆时针方向是减，每一个bit pattern可以表示对应的满足同余性质的数，如我可以规定000代表0，我也可以规定它代表8。既然每个pattern表示的数字由我定义，我是不是就可以把代表0的pattern往逆时针方向的第一pattern定义为-1，第二个定义为-2呢？基于这样的想法，定义了负数的表示。最后多了一个100，定义为-4还是4呢？观察数的特征，负数都是1开头的，那么不妨直接把100定义为-4，保持负数开头为1这样的特征，方便判断正负。</p>
<p>从代数的角度证明：N-bit 2's complement 因为既能表示正数，也能表示负数，所以相应表示的正数少了一点，若采取对半开的原则(<span class="arithmatex">\(2^{N-1}个\)</span>)，可以表示负数的绝对值从[1,<span class="arithmatex">\(2^{N-1}-1\)</span>]（下面的证明过程和ppt完全一样，个人感觉挺妙的）</p>
<p>对每一个k <span class="arithmatex">\(\in\)</span> [1,<span class="arithmatex">\(2^{N-1}-1\)</span>]，我们希望在N位bit pattern里面找到一个pattern(P)可以用来表示 -k这个负数，要满足同余算律（我们希望这个pattern可以被当作普通的unsign-representation一样进行运算）即
$$
-K + M \equiv P + M \pmod{2^N} \quad {\text 此处M为任意整数}
$$
P是某个bit pattern，这个bit pattern在传统的unsigned-representation中代表的数值范围是[0,<span class="arithmatex">\(2^{N-1}-1\)</span>]，这么说有点抽象，假设N是三，P就是000 001 010 011 100 101 110 111这八个bit pattern当中的一个
$$
-K + M \equiv P + M \pmod{2^N} \quad {\text 此处M为任意整数}
$$
根据同余运算律，上面式子等价于下面式子
$$
-K \equiv P  \pmod{2^N} 
$$
已知
$$
2^N \equiv 0  \pmod{2^N} 
$$
得到
$$
2^N - K \equiv P + 0  \pmod{2^N} 
$$
因为K <span class="arithmatex">\(\in\)</span> [1,<span class="arithmatex">\(2^{N-1}-1\)</span>],所以<span class="arithmatex">\(2^N - K\)</span> <span class="arithmatex">\(\in\)</span> [<span class="arithmatex">\(2^{N-1}\)</span>,<span class="arithmatex">\(2^{N}-1\)</span>]这个pattern已经落在[0,<span class="arithmatex">\(2^{N-1}-1\)</span>]的范围内了，就是说可以用N位的representation表示了，因此把这个既符合位数要求，又符合运算要求的bit pattern定义为-k的表示</p>
<p>既然-K(e.g -3)用 <span class="arithmatex">\(2^N - K\)</span>(e.g 8-3 = 5 -&gt; 101)表示了，应该如何实现十进制整数和2's complement之间的转化呢？</p>
<p>一下循序渐进讲解两种转换的方式，选择一种自己喜欢的掌握就可以</p>
<p>1.定义法</p>
<p>-K 用的是<span class="arithmatex">\(2^N - K\)</span>的pattern</p>
<ul>
<li>确定是多少bit的2's complement (e.g 7-bits 2's complement)</li>
<li>从十进制转化到二进制：e.g -42 用的是 <span class="arithmatex">\(2^7 = 128 - 42 = 86\)</span>用的是86的pattern，再把86这个数直接转化成二进制就是-42的7-bits 2's complement表示（如何转化参考unsigned representation短除法），得1010110</li>
<li>从二进制转化到十进制：<span class="arithmatex">\((1010110)_2\)</span>表示的十进制数是多少？先看首位，1开头，确定是负数；再把这个数直接转化成十进制，<span class="arithmatex">\(1*2^6 + 1*2^4 + 1*2^2 + 1*2^1 = 86\)</span>; 再用<span class="arithmatex">\(2^7\)</span>减去86，得到42，最后加上符号</li>
</ul>
<p>补充（二进制转化到十进制简化）：转化过程无非是把<span class="arithmatex">\(2^N - K\)</span>先转化成十进制，然后减去<span class="arithmatex">\(2^N\)</span>，由于2's complement里面的负数都有一个特性，就是开头必定是1，所以一定会有<span class="arithmatex">\(1*2^{N-1}\)</span>这一项，可以把<span class="arithmatex">\(1*2^{N-1}\)</span>和<span class="arithmatex">\(-2^N\)</span>合并一下，就变成了<span class="arithmatex">\(-2^{N-1}\)</span>,所以就是第一位1前加负号，其他正常运算<span class="arithmatex">\(-1*2^6 + 1*2^4 + 1*2^2 + 1*2^1 = -42\)</span>直接得到结果</p>
<p>2.补码法</p>
<p>通过一点小技巧化简运算过程，这种运算方法也是2's complement的名称由来</p>
<ul>
<li>从十进制转化到二进制</li>
<li>1.确定转化的数位(e.g 7-bits 2's complement)</li>
<li>2.确定要转化的数是正数还是负数(e.g -42)</li>
<li>3.用短除把带转化数的绝对值转化成二进制 42 -&gt; <span class="arithmatex">\((101010)_2\)</span></li>
<li>4.补齐数位：7-bits，转化完只有6-bits，前面填0补到7位 <span class="arithmatex">\((0101010)_2\)</span></li>
<li>5.如果第2步中确定的数为正数，则到此为止，如果为负数，继续转化</li>
<li>6.把0变成1，1变成0（补码） <span class="arithmatex">\((1010101)_2\)</span></li>
<li>7.二进制运算 + 1 <span class="arithmatex">\((1010101)_2 + 1 = (1010110)_2\)</span></li>
</ul>
<p>看到这里，你也许会感到奇怪，为什么补码法和前面的方法是等价的呢？让我们回归定义 -k 用的是 <span class="arithmatex">\(2^N - K\)</span>的bit pattern，对<span class="arithmatex">\(2^N - K\)</span>做一点小小的变形，<span class="arithmatex">\(2^N - K = ((2^N - 1 )- K ) + 1\)</span>，而<span class="arithmatex">\(2^N - 1\)</span>这个数是非常有特点的，<span class="arithmatex">\(2^N\)</span>转换到二进制表示中，就是只有第N+1位上的数字是1，其他数字全是0的数，而<span class="arithmatex">\(2^N - 1\)</span>转化到二进制表示中，每一位上的数字都是1。当全是1的减去另外一个数，在二进制运算中，相当于1变0，0变1，e.g 111111 - 00101 = 11010,这样的话，我们就通过取1的补码的方式，得到了<span class="arithmatex">\((2^N - 1)- K\)</span>的运算结果，然后再加1就可以得到最终的表示</p>
<ul>
<li>从二进制转化到十进制方法1</li>
<li>1.确定转化的数位(e.g 7-bits 2's complement)</li>
<li>2.确定要转化的数是正数还是负数(e.g 1010110)，这点可以看首位数字是1还是0非常直接的得到</li>
<li>3.如果是正数，直接转化成十进制</li>
<li>4.如果为负数，先取补码（1010110 -&gt; 0101001），再加1（0101010），再转化成十进制，添上符号</li>
</ul>
<p>这又是什么原理呢？-K 用的是 <span class="arithmatex">\(2^N - K\)</span>的bit pattern </p>
<p>我们拿到的带转化的pattern是<span class="arithmatex">\(2^N - K\)</span>，希望得到的是K，变形一下<span class="arithmatex">\(2^N - (2^N - K) = K\)</span>,再变形一下<span class="arithmatex">\(((2^N - 1) - (2^N - K)) + 1 = K\)</span>，所以取补码的这一步相当于在进行<span class="arithmatex">\((2^N - 1) - (2^N - K)\)</span>，然后再加1得到的就是正数k</p>
<p>一点个人的思考（与考试无关，考试掌握前面算法就可）</p>
<p>我当初看到2.补码法中二进制转化到十进制，在还没仔细思考之前，感到大为惊讶，what？这东西居然不是对称的？之前十进制转化二进制的过程有+1，那么二进制转化成十进制的时候应该有个-1的过程才对啊？怎么会还是加1呢？仔细想想是可以有-1这个过程，即<span class="arithmatex">\(((2^N - 1) - (2^N - K - 1))  = K\)</span>，先减1，再取补码（这样就和十进制转化成二进制完全对称了，当时是先取补码，再加1），如果有追求对称美的uu也可以用这种先减1，再取补码的算法（狗头）</p>
<p>想完之后觉得这些算法都太麻烦啦，本质都是-K 用的是 <span class="arithmatex">\(2^N - K\)</span>的bit pattern，似乎还是定义法最简单粗暴hhh</p>
<p>2's complement还有一个重要的考点是减法运算的时候利用补码来化简运算 e.g 01001000 – 00110111 
一般的减法运算：(若本位不够减就向前一位借，与十进制的运算相同)</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>1</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>-</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong><em>_</em></strong></td>
<td>___</td>
<td>___</td>
<td>___</td>
<td>___</td>
<td>___</td>
<td>___</td>
<td>___</td>
<td>___</td>
</tr>
<tr>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>减法变加法：减去一个数等于加上这个数的相反数：e.g 4 - 2 = 4 + (-2) 由前面的转化法则，我们知道，一个正数在2's complement里面要变成其相反数（对应的负数），就先取补码再加1，同样如果一个负数想要转化成相反数（相应的正数），也是先取补码再加1，因此，在2's complement里面得到相反数就是先取补码再加1 : 01001000 - 00110111 =01001000 + 11001000 + 1 = 01001000 + 11001001 = 00010001 两者相加，最高位会进一个1，本来应该是100010001，但是由于数位固定，取后8位，保留结果位00010001，那么这个影响结果的正确性嘛？-&gt; overflow问题，见<a href="#overflow-problem">Overflow problem</a></p>
<p>2's complement还存在一个考点：假设原来是4bits的2's complement，现在我想把它扩展成8bits的2's complement应该如何操作</p>
<ul>
<li>正数：简单 e.g 0111(7)，直接在前面添零，变成0000 0111（7）</li>
<li>负数：在前面添1 e.g 1000(-8) -&gt; 1111 1000 -&gt; 转化 0000 0111 + 1 = 0000 1000 -&gt; -8 不过为什么添1就是对的，假设我原来是N位2's complement，现在扩展到N+K位，原来-m用的是<span class="arithmatex">\(2^N - m\)</span>的bit pattern，现在我希望-m用<span class="arithmatex">\(2^{N+K} - m\)</span>的bit pattern，两者之间相差多少呢？<span class="arithmatex">\((2^{N+K} - m) - (2^N - m) = 2^N \times (2^k - 1)\)</span>, 其中<span class="arithmatex">\(2^k - 1\)</span>就是111...的形式，总共有k个1，而<span class="arithmatex">\(2^N\)</span>，联想一下多项式表达，<span class="arithmatex">\((2^k - 1) \times 2^N\)</span>，是不是就是从第N为开始在前面加k个1</li>
<li>总：在前面重复符号位，直到满足数位要求</li>
</ul>
<p>考点：1.十进制与2's complement之间的互相转换 2.2's complement 运算的加<em>减</em>法 3.bits位数的扩展 4.overflow问题，见<a href="#overflow-problem">Overflow problem</a></p>
<h2 id="fixed-point-representation">Fixed Point representation<a class="headerlink" href="#fixed-point-representation" title="Permanent link">&para;</a></h2>
<p>(not very important: because it is not a good representation)</p>
<p>成功的表示了整数的正负数，扩展一下数域，我们来到了实数的世界，这里需要考虑如何表示小数点。</p>
<p>第一种想法非常简单，比如我有8个bits，那么我规定前4个bits用来表示小数点前的数字，后4个用来表示小数点后的数字，不足的部分用0补齐 e.g 3.2 3 -&gt; 11 -&gt; 0011 2 -&gt; 10 -&gt; 0010 综合起来就是00110010</p>
<p>问题：</p>
<ul>
<li>在实际应用中，需要表示的实数范围特别广，从很大的数字如<span class="arithmatex">\(6 \times 10^{22}\)</span>到很小的数字，如<span class="arithmatex">\(6 \times 10^{-22}\)</span>，就需要非常多bits来表示实数，很不划算</li>
</ul>
<h2 id="floating-point-representation">Floating Point representation<a class="headerlink" href="#floating-point-representation" title="Permanent link">&para;</a></h2>
<p>Floating Point representation借用了科学计数法的想法来表示浮点数</p>
<ul>
<li>符号位sign来表示正负，1为负数，0为正数</li>
<li>exponent位来表示指数，实际的指数位是exponent转化为十进制之后再减去127得到的结果。为什么要这样设计呢？这样从bit pattern <span class="arithmatex">\((0000 0000)_2\)</span> - <span class="arithmatex">\((0111 1111)_2\)</span>对应的实际指数是-127 - 0， 而bit pattern <span class="arithmatex">\((1000 0000)_2\)</span> - <span class="arithmatex">\((1111 1111)_2\)</span>对应的实际指数为1 - 128，也就是说1开头的指数一定为正数，0开头的为非正数(和signed representation正好反一反!) </li>
<li>mantissa位来代表小数，由于在标准的科学计数法中，小数点前一位不能是0，在二进制中不是0就是1，所以小数点前的一位只有1这种可能就不需要用bit来记录了</li>
</ul>
<p><img alt="single_precision_floating_point_representation" src="../picture/c1/single_precision_floating_point_representation.png" /></p>
<p>问题：
- 由于默认小数点前的一位是1，所以floating point representation有个很大的问题，就是它不能表示 0，最接近0的数有两个1 00000000  mantissa均为0(<span class="arithmatex">\(-1 \times 2^{-127}\)</span>)和0 00000000  mantissa均为0(<span class="arithmatex">\(1 \times 2^{-127}\)</span>)
- 解决方案：人为规定后者，即32位全部为0的情况表示0这个数
- 对于exponent位全部是1的情况，也有特殊的人为规定，1 11111111  mantissa均为0，代表负无穷，0 11111111 mantissa均为0，代表正无穷，如果指数位为11111111，但是mantissa不全为0，则代表not a number</p>
<p>个人思考：为什么不用2's complement来表示指数位？由于2's complement设计初衷是使得数之间的加减仍然可以遵循unsigned representation中的模式，但是在floating point representation中无论怎么设计，都不可能做到遵循原来的运算模式（即，直接把每位binary数相加，该进位就进位，最终得到的结果就是在该representation下的正确答案）而signed representation的数制转化过程过于麻烦，用在此处不能带来好处，所以就干脆采用了-127这样的想法</p>
<p>1.floating point representation转化成十进制（根据定义来即可） e.g 1 01011000 10111010000000000000000 </p>
<ul>
<li>符号位为1，负数</li>
<li>指数位01011000 = <span class="arithmatex">\(1 \times 2^6 + 1 \times 2^4 + 1 \times 2^3 = 88\)</span> 88 - 127 = -39</li>
<li>小数位1011101 = <span class="arithmatex">\(1 \times 2^{-1} + 1 \times 2^{-3} + 1 \times 2^{-4} + 1 \times 2^{-5} + 1 \times 2^{-7}\)</span> = 0.7265625</li>
<li>综合起来 <span class="arithmatex">\(-1.7265625 \times 2^{-39}\)</span></li>
</ul>
<p>2.十进制小数转化成floating point representation e.g -4.2</p>
<ul>
<li>先把整数部分转化成二进制 4 -&gt; 100</li>
<li>再转化小数部分 根据多项式表达（参考<a href="#unsign-representation">unsigned representation</a>）</li>
<li><span class="arithmatex">\(F = a_{-1} \times 2^{-1} + a_{-2} \times 2^{-2} + a_{-3} \times 2^{-3}\)</span></li>
<li>根据公式，如果把<span class="arithmatex">\(F \times 2\)</span>，会得到<span class="arithmatex">\(a_{-1} + a_{-2} \times 2^{-1} + a_{-3} \times 2^{-2}\)</span>，如果<span class="arithmatex">\(a_{-1}\)</span>不是0的话，小数点前就会有一个1，<span class="arithmatex">\(a_{-2} a_{-3}\)</span>一定还是在小数点后面的，依据同样的方法，每次乘二，看整数部分有没有进位，如果进位的话，说明该小数位为1，否则为0，然后取乘二结果的小数部分继续运算（十进制转二进制的时候，整数部分通过不停的除2来算，而小数部分则通过不停的乘2来算）</li>
<li>0.2 * 2 = 0.4   <span class="arithmatex">\(a_{-1} =  0\)</span></li>
<li>0.4 * 2 = 0.8   <span class="arithmatex">\(a_{-2} =  0\)</span></li>
<li>0.8 * 2 = 1.6   <span class="arithmatex">\(a_{-3} =  1\)</span></li>
<li>0.6 * 2 = 1.2   <span class="arithmatex">\(a_{-4} =  1\)</span></li>
<li>0.2 * 2 = 0.4   <span class="arithmatex">\(a_{-5} =  0\)</span>（至此开始循环）</li>
<li>得到小数部分为 0011 0011 0011 ...(在十进制里面的有限小数转化为floating point representation之后可能是无限循环)</li>
<li>把整数和小数整合在一起 100.0011 0011 0011 ...</li>
<li>写成科学计数法的形式 1.00 0011 0011 0011 ... <span class="arithmatex">\(\times 2^2\)</span></li>
<li>确定exponent位：2 + 127 = 129 = 1000 0001 </li>
<li>添上正负号，写成floating point representation的形式 1 10000001 00001100110011001100110 （无限不循环，但是mantissa的位数有限，所以写到有限位）</li>
</ul>
<p>3.Non-associative性质</p>
<p>一般数值表示的运算中满足结合率，即 (A + B) + C = A + (B + C)，但是floating point是不满足的，在floating point representation中，<span class="arithmatex">\((2^{-30} + 1) - 1 = 0\)</span>， 为什么呢？1.floating point representation可以把<span class="arithmatex">\(2^{-30}\)</span>单独表示出来，大概是 0 01100001 000000... 2.floating point representation可以把1单独表示出来，大概是0 01111111 00000... 3.但是两者相加的结果却无法表示，exponent必须是01111111（因为1的存在，exponent转化为10进制之后必须是<span class="arithmatex">\(2^0\)</span>），但是mantissa只有23位，<span class="arithmatex">\(2^{-30}\)</span>需要写到第30位的时候才有一个1，超出了mantissa的范围，所以当<span class="arithmatex">\(2^{-30}\)</span>与1相加的时候，<span class="arithmatex">\(2^{-30}\)</span>被舍掉了，相加结果就是1，1在减去1得0。但是如果运算顺序发生变化<span class="arithmatex">\(2^{-30} + （1 - 1） = 0\)</span>两个1相减得0后在于<span class="arithmatex">\(2^{-30}\)</span>，floating point representation就可以准确的表示结果了</p>
<p>考点：1.小数和floating point representation之间的转化 2.non-associative的性质 </p>
<h2 id="overflow-problem">Overflow Problem<a class="headerlink" href="#overflow-problem" title="Permanent link">&para;</a></h2>
<p>1.Unsigned Representation:</p>
<ul>
<li>overflow: <span class="arithmatex">\(A + B &gt; 2^N\)</span> 当最高位产生进位的时候，就会出现overflow的情况</li>
</ul>
<p>2.2's Complement:</p>
<ul>
<li>正数加正数：相加得到负数（结果首位为1的时候overflow）-&gt; 对于N位的2's Complement，正数的范围是[1,<span class="arithmatex">\(2^{N-1}-1\)</span>],相加后可能的范围为[2,<span class="arithmatex">\(2^{N}-2\)</span>],但是在[<span class="arithmatex">\(2^{N-1}\)</span>,<span class="arithmatex">\(2^N - 1\)</span>]范围内的bit pattern被用来表示负数了，如果相加结果落入到这个范围（即最高位为1的范围），那么就是overflow</li>
<li>负数加负数：相加得到正数（结果首位为0的时候overflow）-&gt; 对于N位的2's Complement，负数的范围是[<span class="arithmatex">\(-2^{N-1}\)</span>,-1],相加后可能的范围为[<span class="arithmatex">\(-2^{N}\)</span>,-2],因为-K对应的bit pattern是<span class="arithmatex">\(2^N - k\)</span>，相加后的bit pattern是[0,<span class="arithmatex">\(2^N-2\)</span>]，但是在[1,<span class="arithmatex">\(2^{N-1}-1\)</span>]这个范围的bit pattern被用来表示正数了，如果相加结果落入到这个范围（即最高位为0的范围），那么就是overflow</li>
<li>正数加负数：永远不会overflow [1,<span class="arithmatex">\(2^{N-1}-1\)</span>] + [<span class="arithmatex">\(-2^{N-1}\)</span>,-1] = [<span class="arithmatex">\(-2^{N-1} + 1\)</span>, <span class="arithmatex">\(2^{N-1}-2\)</span>]落在2's complement可以表示的范围内</li>
<li>！！！2's complement overflow的判断不取决于最高位有没有进位 e.g 1100(-4) + 0111(7) = 0011(3) 有进位但是没有overflow</li>
</ul>
<h2 id="hexadecimal">Hexadecimal<a class="headerlink" href="#hexadecimal" title="Permanent link">&para;</a></h2>
<p>与十进制的转化方式本质原理都是多项式表达，方法同unsigned-representation；与二进制转化的时候可以采取四位一转的方式，因为16 = <span class="arithmatex">\(2^4\)</span></p>
<h2 id="_2">写在最后的话<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<p>在计算机里，二进制不仅要表示数，还要表示很多东西，如声音，文字，都有自己的编码方式。bit pattern本身是不具有意义的，一串bits 10101010，你可以说它是unsigned编码下的170，也可是2's complement编码下的-86，还可以是ASCII编码下[line feed] [line feed]。考试的时候可能会考到对于N个不同的东西，要多少位bits才能表示这些东西 -&gt; <span class="arithmatex">\(\lceil \log_2 N \rceil\)</span></p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
